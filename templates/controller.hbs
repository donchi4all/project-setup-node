import {
    Body,
    Controller,
    Get,
    Path,
    Patch,
    Put,
    Post,
    Delete,
    Query,
    Route,
    SuccessResponse,
    Tags,
} from "tsoa";
import {{service}}Service from "../../services/{{service}}";
import httpStatuses from "../../../api/httpStatuses";
import { LoggerDecorator, LoggerInterface } from "../../../modules/logger";
import I{{capitalize service}}Interface, { {{capitalize service}}CreationType, I{{capitalize service}}BulkUpdateInterface } from "../../models/{{service}}/I{{capitalize service}}";
import { removeUndefined } from "../../../utils";
import { {{capitalize service}}sDto } from "../../services/{{service}}/dtos/{{service}}.dto";
import {{service}}sService from "../../services/{{service}}";
import { IPagination } from "../../../utils/queries/interface";
import { ResponseTypeEnum, SuccessResponseModel } from "../../../modules/routes/response";


@Route('{{service}}s')
@Tags('{{capitalize service}}s')
export class {{capitalize service}}sController extends Controller {
    @LoggerDecorator('Controller.{{uppercase service}}')
    private log: LoggerInterface;

    @SuccessResponse(httpStatuses.success.code, httpStatuses.success.message)
    @Post()
    public async create{{capitalize service}}(
        @Body() requestBody: {{capitalize service}}CreationType
    ): Promise<SuccessResponseModel<I{{capitalize service}}Interface>> {
        try {
            let data = new {{capitalize service}}sDto(requestBody);
            data = removeUndefined(data) as {{capitalize service}}sDto;

            const create{{capitalize service}} = await {{service}}Service.create(data);
            return new SuccessResponseModel<I{{capitalize service}}Interface>(create{{capitalize service}})
        } catch (err) {
            this.log.error(`Route /{{service}}s post with err: ${err}`);
            throw err
        }
    }

    @SuccessResponse(httpStatuses.success.code, httpStatuses.success.message)
    @Get()
    public async list{{capitalize service}}s( 
    @Query() page: number = 0,
    @Query() limit: number = 50,
    @Query() search?: string,
    @Query() from?: string,
    @Query() to?: string
    ): Promise<SuccessResponseModel<I{{capitalize service}}Interface[]>> {
        try {
            let queries = {page, limit, search, from, to};
            queries = removeUndefined(queries);
           
            const { data: list{{capitalize service}}s, pagination } = await {{service}}Service.findAll(queries);
          
            return new SuccessResponseModel<I{{capitalize service}}Interface[]>(list{{capitalize service}}s, "{{capitalize service}}'s successfully listed", ResponseTypeEnum.SUCCESS, pagination);
        } catch (err) {
            this.log.error(`Route /{{service}}s get with err: ${err}`);
            throw err
        }
    }

    @SuccessResponse(httpStatuses.success.code, httpStatuses.success.message)
    @Get('{ {{~service~}}Id}')
    public async getOne{{capitalize service}}({{service}}Id: string): Promise<SuccessResponseModel<I{{capitalize service}}Interface>> {
        try {
            const found{{capitalize service}} = await {{service}}Service.findOne({{service}}Id);
            return new SuccessResponseModel<I{{capitalize service}}Interface>(found{{capitalize service}}, "{{capitalize service}} successfully retrieved", ResponseTypeEnum.SUCCESS);
        } catch (err) {
            this.log.error(`Route /{{service}}s/${{service}}Id get with err: ${err}`);
            throw err
        }
    }

    @SuccessResponse(httpStatuses.success.code, httpStatuses.success.message)
    @Patch('{ {{~service~}}Id}')
    public async update{{capitalize service}}({{service}}Id: string, @Body() requestBody: {{capitalize service}}CreationType ): Promise<I{{capitalize service}}Interface> {
        try {
            let data = new {{capitalize service}}sDto(requestBody);
            data = removeUndefined(data) as {{capitalize service}}sDto;
           
            await {{service}}Service.updateOne(data, {{service}}Id);
            return await {{service}}Service.findOne({{service}}Id);
        } catch (err) {
            this.log.error(`Route /{{service}}s/${{service}}Id patch with err: ${err}`);
            throw err
        }
    }

    @SuccessResponse(httpStatuses.success.code, httpStatuses.success.message)
    @Put()
    public async updateMany{{capitalize service}}(@Body()requestBody: I{{capitalize service}}BulkUpdateInterface): Promise<{message: string}> {
        try {
            const body = requestBody;
            const ids = requestBody.ids;
            let data = new {{capitalize service}}sDto(body);
            data = removeUndefined(data) as {{capitalize service}}sDto;
           
            await {{service}}sService.updateMany(data, ids);
            return { message: '{{capitalize service}}s updated successfully' };
        } catch (err) {
            this.log.error(`Route /{{service}}s put with err: ${err}`);
            throw err
        }
    }

    @SuccessResponse(httpStatuses.success.code, httpStatuses.success.message)
    @Delete('{ {{~service~}}Id}')
    public async delete{{capitalize service}}({{service}}Id: string): Promise<{message: string}> {
        try {
            const id = {{service}}Id;           
            await {{service}}Service.delete(id);
            return { message: '{{capitalize service}} deleted successfully' };
        } catch (err) {
            this.log.error(`Route /{{service}}s delete with err: ${err}`);
            throw err
        }
    }

    @SuccessResponse(httpStatuses.success.code, httpStatuses.success.message)
    @Delete()
    public async deleteMany{{capitalize service}}s( @Body() requestBody: { ids: I{{capitalize service}}BulkUpdateInterface['ids'] }): Promise<{message: string}> {
        try {
            const ids = requestBody.ids;       
            await {{service}}sService.deleteMany(ids);
            return { message: '{{capitalize service}}s deleted successfully' };
        } catch (err) {
            this.log.error(`Route /{{service}}s delete with err: ${err}`);
            throw err
        }
    }
}
