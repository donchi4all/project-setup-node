import {
    Body,
    Controller,
    Get,
    Path,
    Patch,
    Put,
    Post,
    Delete,
    Query,
    Route,
    SuccessResponse,
    Tags,
} from "tsoa";

import {{singular service}}Service from "../../services/{{singular service}}";
import httpStatuses from "../../../api/httpStatuses";
import { LoggerDecorator, LoggerInterface } from "../../../modules/logger";
import I{{capitalizeSingular service}}Interface, {
    {{capitalizeSingular service}}CreationType,
    I{{capitalizeSingular service}}BulkUpdateInterface
} from "../../models/{{singular service}}/I{{capitalizeSingular service}}";
import { removeUndefined } from "../../../utils";
import { {{capitalizeSingular service}}Dto } from "../../services/{{singular service}}/dtos/{{singular service}}.dto";
import { ResponseTypeEnum, SuccessResponseModel } from "../../../modules/routes/response";

@Route("{{plural service}}")
@Tags("{{capitalizePlural service}}")
export class {{capitalizePlural service}}Controller extends Controller {

    @LoggerDecorator("Controller.{{uppercase service}}")
    private log: LoggerInterface;

    /**
     |---------------------------------------------------
     | SUMMARY
     |---------------------------------------------------
     | Creates a new {{capitalizeSingular service}} record.
     |
     | **Flow:**
     | - Accepts {{capitalizeSingular service}} payload
     | - Validates and sanitizes input
     | - Persists record in storage
     |
     |---------------------------------------------------
     | INSTRUCTIONS
     |---------------------------------------------------
     | 1. Provide valid {{capitalizeSingular service}} payload.
     | 2. All undefined values will be removed automatically.
     | 3. Successfully created record will be returned.
     |
     |---------------------------------------------------
     | @param requestBody - {{capitalizeSingular service}} creation payload
     | @returns Newly created {{capitalizeSingular service}}
     |
     | @route POST /{{plural service}}
     | @tags {{capitalizePlural service}}
     | @summary Create {{capitalizeSingular service}}
     */
    @SuccessResponse(httpStatuses.success.code, httpStatuses.success.message)
    @Post()
    public async create{{capitalizeSingular service}}(
        @Body() requestBody: {{capitalizeSingular service}}CreationType
    ): Promise<SuccessResponseModel<I{{capitalizeSingular service}}Interface>> {
        try {

            let data = new {{capitalizeSingular service}}Dto(requestBody);
            data = removeUndefined(data) as {{capitalizeSingular service}}Dto;

            const created = await {{singular service}}Service.create(data);

            return new SuccessResponseModel<I{{capitalizeSingular service}}Interface>(created);

        } catch (err) {
            this.log.error(`Route /{{plural service}} POST error: ${err}`);
            throw err;
        }
    }

    /**
     |---------------------------------------------------
     | SUMMARY
     |---------------------------------------------------
     | Retrieves paginated list of {{plural service}}.
     |
     | **Flow:**
     | - Accepts pagination and filtering parameters
     | - Fetches matching records
     | - Returns records with pagination metadata
     |
     |---------------------------------------------------
     | INSTRUCTIONS
     |---------------------------------------------------
     | 1. Provide pagination parameters if required.
     | 2. Use search, date filters for refined results.
     |
     |---------------------------------------------------
     | @returns Paginated list of {{plural service}}
     |
     | @route GET /{{plural service}}
     | @tags {{capitalizePlural service}}
     | @summary List {{capitalizePlural service}}
     */
    @SuccessResponse(httpStatuses.success.code, httpStatuses.success.message)
    @Get()
    public async list{{capitalizePlural service}}(
        @Query() page: number = 0,
        @Query() limit: number = 50,
        @Query() search?: string,
        @Query() from?: string,
        @Query() to?: string
    ): Promise<SuccessResponseModel<I{{capitalizeSingular service}}Interface[]>> {

        try {

            let queries = removeUndefined({ page, limit, search, from, to });

            const { data, pagination } = await {{singular service}}Service.findAll(queries);

            return new SuccessResponseModel<I{{capitalizeSingular service}}Interface[]>(
                data,
                "{{capitalizePlural service}} successfully listed",
                ResponseTypeEnum.SUCCESS,
                pagination
            );

        } catch (err) {
            this.log.error(`Route /{{plural service}} GET error: ${err}`);
            throw err;
        }
    }

    /**
     |---------------------------------------------------
     | SUMMARY
     |---------------------------------------------------
     | Retrieves a single {{capitalizeSingular service}} by ID.
     |
     |---------------------------------------------------
     | INSTRUCTIONS
     |---------------------------------------------------
     | 1. Provide valid {{singular service}}Id.
     |
     |---------------------------------------------------
     | @param {{singular service}}Id - Unique identifier
     | @returns {{capitalizeSingular service}} record
     |
     | @route GET /{{plural service}}/{id}
     | @tags {{capitalizePlural service}}
     | @summary Get {{capitalizeSingular service}}
     */
    @SuccessResponse(httpStatuses.success.code, httpStatuses.success.message)
    @Get("{ {{~singular service~}}Id}")
    public async getOne{{capitalizeSingular service}}(
        @Path() {{singular service}}Id: string
    ): Promise<SuccessResponseModel<I{{capitalizeSingular service}}Interface>> {

        try {

            const found = await {{singular service}}Service.findOne({{singular service}}Id);

            return new SuccessResponseModel(
                found,
                "{{capitalizeSingular service}} successfully retrieved",
                ResponseTypeEnum.SUCCESS
            );

        } catch (err) {
            this.log.error(`Route /{{plural service}}/${ {{~singular service~}}Id} GET error: ${err}`);
            throw err;
        }
    }

    /**
     |---------------------------------------------------
     | SUMMARY
     |---------------------------------------------------
     | Updates a single {{capitalizeSingular service}}.
     |
     |---------------------------------------------------
     | INSTRUCTIONS
     |---------------------------------------------------
     | 1. Provide {{singular service}}Id.
     | 2. Provide update payload.
     |
     |---------------------------------------------------
     | @route PATCH /{{plural service}}/{id}
     | @tags {{capitalizePlural service}}
     | @summary Update {{capitalizeSingular service}}
     */
    @SuccessResponse(httpStatuses.success.code, httpStatuses.success.message)
    @Patch("{ {{~singular service~}}Id}")
    public async update{{capitalizeSingular service}}(
        @Path() {{singular service}}Id: string,
        @Body() requestBody: {{capitalizeSingular service}}CreationType
    ): Promise<I{{capitalizeSingular service}}Interface> {

        try {

            let data = new {{capitalizeSingular service}}Dto(requestBody);
            data = removeUndefined(data) as {{capitalizeSingular service}}Dto;

            await {{singular service}}Service.updateOne(data, {{singular service}}Id);

            return await {{singular service}}Service.findOne({{singular service}}Id);

        } catch (err) {
            this.log.error(`Route /{{plural service}}/${ {{~singular service~}}Id} PATCH error: ${err}`);
            throw err;
        }
    }

    /**
     |---------------------------------------------------
     | SUMMARY
     |---------------------------------------------------
     | Bulk updates multiple {{plural service}}.
     |
     |---------------------------------------------------
     | INSTRUCTIONS
     |---------------------------------------------------
     | 1. Provide list of IDs.
     | 2. Provide update payload.
     |
     |---------------------------------------------------
     | @route PUT /{{plural service}}
     | @tags {{capitalizePlural service}}
     | @summary Bulk update {{capitalizePlural service}}
     */
    @SuccessResponse(httpStatuses.success.code, httpStatuses.success.message)
    @Put()
    public async updateMany{{capitalizeSingular service}}(
        @Body() requestBody: I{{capitalizeSingular service}}BulkUpdateInterface
    ): Promise<{ message: string }> {

        try {

            const { ids, ...body } = requestBody;

            let data = new {{capitalizeSingular service}}Dto(body);
            data = removeUndefined(data) as {{capitalizeSingular service}}Dto;

            await {{singular service}}Service.updateMany(data, ids);

            return { message: "{{capitalizePlural service}} updated successfully" };

        } catch (err) {
            this.log.error(`Route /{{plural service}} PUT error: ${err}`);
            throw err;
        }
    }

    /**
     |---------------------------------------------------
     | SUMMARY
     |---------------------------------------------------
     | Deletes a single {{capitalizeSingular service}}.
     |
     |---------------------------------------------------
     | @route DELETE /{{plural service}}/{id}
     | @tags {{capitalizePlural service}}
     | @summary Delete {{capitalizeSingular service}}
     */
    @SuccessResponse(httpStatuses.success.code, httpStatuses.success.message)
    @Delete("{ {{~singular service~}}Id}")
    public async delete{{capitalizeSingular service}}(
        @Path() {{singular service}}Id: string
    ): Promise<{ message: string }> {

        try {

            await {{singular service}}Service.delete({{singular service}}Id);

            return { message: "{{capitalizeSingular service}} deleted successfully" };

        } catch (err) {
            this.log.error(`Route /{{plural service}}/${ {{~singular service~}}Id} DELETE error: ${err}`);
            throw err;
        }
    }

    /**
     |---------------------------------------------------
     | SUMMARY
     |---------------------------------------------------
     | Bulk deletes multiple {{plural service}}.
     |
     |---------------------------------------------------
     | @route DELETE /{{plural service}}
     | @tags {{capitalizePlural service}}
     | @summary Bulk delete {{capitalizePlural service}}
     */
    @SuccessResponse(httpStatuses.success.code, httpStatuses.success.message)
    @Delete()
    public async deleteMany{{capitalizePlural service}}(
        @Body() requestBody: { ids: I{{capitalizeSingular service}}BulkUpdateInterface["ids"] }
    ): Promise<{ message: string }> {

        try {

            await {{singular service}}Service.deleteMany(requestBody.ids);

            return { message: "{{capitalizePlural service}} deleted successfully" };

        } catch (err) {
            this.log.error(`Route /{{plural service}} DELETE MANY error: ${err}`);
            throw err;
        }
    }
}